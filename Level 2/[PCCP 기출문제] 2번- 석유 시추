history = []
path_collections=[]
def bfs(i,j,land):
    q = [[(i,j),1]]
    N, M = len(land[0]), len(land)
    path=[]
    max_val_path = 1
    while len(q)!=0 :
        now = q.pop()
        history.append(list(now[0]))
        path.append(list(now[0]))
        max_val_path = max(now[1], max_val_path)
        for d in [[-1,0],[0,-1],[1,0],[0,1]]:
            x, y = now[0][0]+d[0], now[0][1]+d[1]
            if 0<=x<M and 0<=y<N :
                if land[x][y] == 1 :
                    if [x,y] not in path :
                        q.insert(0,[(x,y),now[1]+1])
    print(max_val_path)
    print(path)
    path_collections.append([max_val_path, path])
            
def solution(land):
    answer = 0
    N, M = len(land[0]), len(land)
    for i in range(M):
        for j in range(N):
            if [i,j] not in history :
                if land[i][j] == 1 :
                    bfs(i,j, land)
    global path_collections
    
    return answer
