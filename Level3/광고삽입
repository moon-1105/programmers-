from collections import defaultdict
"""
내풀이 ) => simulator => 시간 초과함 

일단 이 문제의 핵심은 Memoization입니다. 동적 계획법이라고 해야할까요.

어찌됐건, 반복문을 통해 누적 시청자수를 차곡차곡 기록하고, 그걸 나중에 빼서 계산을 진행합니다.
"""
def change_from_time(log):
    return_value = int(log[:2])*60*60 + int(log[3:5])*60 + int(log[6:])
    return return_value

def change_to_time(log):
    first = log//3600
    log -= first*3600
    second = log//60
    log -= second*60
    third = log%60

    if first < 10 :
        first = "0"+str(first)
    if second < 10 :
        second = "0"+str(second)
    if third < 10 :
        third = "0"+str(third)
    return str(first)+":"+str(second)+":"+str(third)

def cal(start, adv_time, logs):
    #tmp_time_line = defaultdict(int)
    val = 0
    for log in logs:
        if start < log[0] and start+adv_time <log[1]:
            val += 1
    return val

def solution(play_time, adv_time, _logs):
    answer = ''
    time_line = defaultdict(int)
    logs=[]
    for log in _logs:
        front, behind = log[:8],log[9:]
        logs.append([change_from_time(front), change_from_time(behind)])
    play_time = change_from_time(play_time)
    adv_time = change_from_time(adv_time)
    
    # 구간 별 시청자 수 기록
    # start = 1, end = -1
    # time_line[i] = time_line[i]+time_line[i-1]
    # 모든 구간 시청자 누적 기록 
    # time_line[i] = time_line[i]+time_line[i-1]
    # 누적을 바탕으로 가장 시청자수가 많은 구간 탐색
    # time_line[i] - time_line[i-adv_time] 이 가장 많은 구간 
    return answer
